function Brick(startX, startY, p, color, strength){
	//const BRICK_WIDTH = <%= Global.tower.brick_width %>;
	Brick.BRICK_WIDTH = <%= Global.tower.brick_width %>;
	Brick.BRICK_HEIGHT = <%= Global.tower.brick_height %>;
	const COLUMNS = <%= Global.tower.bricks_layer %>;
	const BPL = <%= Global.tower.level_height %>;
	const OVERLAP = <%= Global.tower.overlap %>
	//const OVERLAP = 2;

	Brick.towerWidth = Brick.BRICK_WIDTH * COLUMNS;
	if(Brick.offset == null){
		Brick.offset = (p.width - Brick.BRICK_WIDTH * COLUMNS)/2;
	}
	var leftBound = 10;
	var rightBound = p.width - (Brick.BRICK_WIDTH * COLUMNS) - 5;

	var x = startX;
	var y = startY;
	var screenX = xToScreen(x);
	var screenY = yToScreen(y);
	var name = "";

	//This function should check if the brick might go out of bounds
	//And refuse if it does
	this.update = function(newX, newY, offsetX, offsetY){
		x = screenToX(newX) + offsetX;
		y = screenToY(newY) + offsetY;
		screenX = xToScreen(x);
		screenY = yToScreen(y);
	}

	this.setName = function(newName){
		name = newName;
	}

	this.getName = function(){
		return name;
	}

	this.fall = function(){
		y -= 0.1;
	}

	Brick.moveLeft = function(){
		if(Brick.offset < leftBound){
			Brick.offset += 30;
		}
	}

	Brick.moveRight = function(){
		if(Brick.offset > rightBound){
			Brick.offset -= 30;
		}
	}

	this.isWithin = function(mouseX, mouseY){
		return (screenToX(mouseX) == x && screenToY(mouseY) == y)
	}

	Brick.makeSmaller = function(){
		if(Brick.BRICK_WIDTH > 2.5){
			Brick.BRICK_WIDTH *= 0.5;
			Brick.BRICK_HEIGHT *= 0.5;
			Brick.offset = (p.width - Brick.BRICK_WIDTH * COLUMNS)/2;
		}
	}

	Brick.makeLarger = function(){
		if(Brick.BRICK_WIDTH < <%= Global.tower.brick_width %>){
			Brick.BRICK_WIDTH *= 2;
			Brick.BRICK_HEIGHT *= 2;
			Brick.offset = (p.width - Brick.BRICK_WIDTH * COLUMNS)/2;
		}
	}

	this.x = function(){
		return x;
	}

	this.y = function(){
		return y;
	}

	this.color = function(){
		return color;
	}

	//Do I use this function anywhere?
	this.level = function(){
		return Math.floor((y - 1) / BPL);
	}

	Brick.withinTower = function(x, offset){
		return screenToX(x) + offset >= 0 && screenToX(x) + offset < COLUMNS;
	}

	Brick.onLevel = function(y, offset){
		return Math.floor((screenToY(y) + offset - 1 ) / BPL) == Brick.level
	}

	//Given an coordinate, shows where on the screen to draw
	function xToScreen(thisX){
		return thisX * Brick.BRICK_WIDTH + Brick.offset;
	}

	function yToScreen(thisY){
		return p.height - (thisY+1 - Brick.level * BPL) * Brick.BRICK_HEIGHT ;
	}

	// Converts the screen position to the nearest x,y position
	function screenToX(x){
		return Math.floor((x - Brick.offset)/Brick.BRICK_WIDTH);
	}

	function screenToY(y){
		return Math.floor((p.height-y)/Brick.BRICK_HEIGHT) + Brick.level * BPL;
	}

	function pickFill(placed){
		if(placed){
			var a = 150;
		}else{
			var a = 255;
		}
		switch (color){
			case 0:
				p.fill(170, 0, 0, a);
				break;
			case 1:
				p.fill(255, 140, 0, a);
				break;
			case 2:
				p.fill(0, 0, 200, a);
				break;
			default:
				p.fill(0);
		}
	}

	this.draw = function(){
		draw(false);
	}

	this.draw = function(placed){
		if(x >= 0 && x < COLUMNS){
			pickFill(placed);
			p.strokeWeight(1);
			p.rect(xToScreen(x), yToScreen(y), Brick.BRICK_WIDTH, Brick.BRICK_HEIGHT);
			//Let's just try this method of displaying strength and see what happens
			p.strokeWeight(2);
			for(var i = 0; i < strength; i++){
				var xLerp = p.lerp(xToScreen(x), xToScreen(x) + Brick.BRICK_WIDTH, (i+1)/(strength+1));
				p.line(xLerp, yToScreen(y)+5, xLerp, yToScreen(y) + Brick.BRICK_HEIGHT-5);
			}
		}
	}
}

// function BrickCluster(){
// 	const SHIPMENTSIZE = <%= Global.tower.shipment_size %>;

// 	var arrangment = generateArrangement();
// 	var bricks = [];

// 	//Generates the arrangement of bricks. Kind of hacky.
// 	function generateArrangement(){
// 		var ar = []
// 		for(var i = 0; i < SHIPMENTSIZE-1; i++){
// 			ar[i] = []
// 			for(var j = 0; j < 2; j++){
// 				ar[i][j] = Math.floor(Math.random()*3-1);
// 			}
// 		}
// 		//Don't put a new brick on top of my old brick!
// 		if(ar[0][0] == 0 && ar[0][1] == 0){
// 			ar[0][0] = 1;
// 		}
// 		if(ar[1][0] == 0 && ar[1][1] == 0){
// 			ar[1][0] = -1;
// 		}
// 		//If the first and second brick are in the same place
// 		//Throw away one of them
// 		if(ar[0][0] == ar[1][0] && ar[0][1] == ar[1][1]){
// 			ar.shift();
// 		}
// 		return ar;
// 	}

// 	this.draw = function(){

// 	}
// }