function Brick(startX, startY, p, color){
	const BRICK_WIDTH = <%= Rails.configuration.x.brick_width %>;
	const BRICK_HEIGHT = <%= Rails.configuration.x.brick_height %>;
	const COLUMNS = <%= Rails.configuration.x.bricks_layer %>;
	const BPL = <%= Rails.configuration.x.level_height %>;

	Brick.towerWidth = BRICK_WIDTH * COLUMNS;
	Brick.offset = (p.width - BRICK_WIDTH * COLUMNS)/2;
	Brick.level;

	var x = startX;
	var y = startY;
	var screenX = xToScreen(x);
	var screenY = yToScreen(y);

	this.update = function(newX, newY, offsetX, offsetY){
		x = screenToX(newX) + offsetX;
		y = screenToY(newY) + offsetY;
		screenX = xToScreen(x);
		screenY = yToScreen(y);
	}

	//Does this brick appear on the level currently being shown?
	function onLevel(){
		if(y >= Brick.level * BPL - 2 && y <= (Brick.level+1) * BPL){
			return true;
		}else{
			return false;
		}
	}

	this.fall = function(){
		y -= 0.1;
	}

	this.isWithin = function(mouseX, mouseY){
		if(screenToX(mouseX) == x && screenToY(mouseY) == y){
			return true;
		}else{
			return false;
		}
	}

	this.x = function(){
		return x;
	}

	this.y = function(){
		return y;
	}

	this.color = function(){
		return color;
	}


	this.level = function(){
		return (y - y % BPL) / BPL;
	}

	//Given an coordinate, shows where on the screen to draw
	function xToScreen(thisX){
		return thisX * BRICK_WIDTH + Brick.offset;
	}

	function yToScreen(thisY){
		return p.height - (thisY+1 - Brick.level * (BPL - 2)) * BRICK_HEIGHT ;
	}

	// Converts the screen position to the nearest x,y position
	function screenToX(x){
		return Math.floor((x - Brick.offset)/BRICK_WIDTH);
	}

	function screenToY(y){
		return Math.floor((p.height-y)/BRICK_HEIGHT) + Brick.level * (BPL - 2);
	}

	function pickFill(placed){
		if(placed){
			var a = 100;
		}else{
			var a = 255;
		}
		switch (color){
			case 0:
				p.fill(200, 0, 0, a);
				break;
			case 1:
				p.fill(0, 200, 0, a);
				break;
			case 2:
				p.fill(0, 0, 200, a);
				break;
			default:
				p.fill(0);
		}
	}

	this.draw = function(){
		draw(false);
	}

	this.draw = function(placed){
		if(onLevel() && x >= 0 && x < COLUMNS){
			pickFill(placed);
			p.rect(xToScreen(x), yToScreen(y), BRICK_WIDTH, BRICK_HEIGHT);
		}
	}
}

function BrickCluster(){
	const SHIPMENTSIZE = <%= Rails.configuration.x.shipment_size %>;

	var arrangment = generateArrangement();
	var bricks = 

	//Generates the arrangement of bricks. Kind of hacky.
	function generateArrangement(){
		var ar = []
		for(var i = 0; i < SHIPMENTSIZE-1; i++){
			ar[i] = []
			for(var j = 0; j < 2; j++){
				ar[i][j] = Math.floor(Math.random()*3-1);
			}
		}
		//Don't put a new brick on top of my old brick!
		if(ar[0][0] == 0 && ar[0][1] == 0){
			ar[0][0] = 1;
		}
		if(ar[1][0] == 0 && ar[1][1] == 0){
			ar[1][0] = -1;
		}
		//If the first and second brick are in the same place
		//Throw away one of them
		if(ar[0][0] == ar[1][0] && ar[0][1] == ar[1][1]){
			ar.shift();
		}
		return ar;
	}

	this.draw = function(){

	}
}