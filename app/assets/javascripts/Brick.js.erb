function Brick(startX, startY, p, color, strength){
	//const BRICK_WIDTH = <%= Global.tower.brick_width %>;
	Brick.BRICK_WIDTH = <%= Global.tower.brick_width %>;
	Brick.BRICK_HEIGHT = <%= Global.tower.brick_height %>;
	const COLUMNS = <%= Global.tower.bricks_layer %>;
	const BPL = <%= Global.tower.level_height %>;
	const OVERLAP = <%= Global.tower.overlap %>
	//const OVERLAP = 2;

	Brick.towerWidth = Brick.BRICK_WIDTH * COLUMNS;
	if(Brick.offset == null){
		Brick.offset = (p.width - Brick.BRICK_WIDTH * COLUMNS)/2;
	}
	if(Brick.verticalOffset == null){
		Brick.verticalOffset = 0;
	}
	var leftBound = 10;
	var rightBound = p.width - (Brick.BRICK_WIDTH * COLUMNS + 10);

	var x = startX;
	var y = startY;
	var screenX = xToScreen(x);
	var screenY = yToScreen(y);
	var id;

	//This function should check if the brick might go out of bounds
	//And refuse if it does
	this.update = function(newX, newY, offsetX, offsetY){
		x = screenToX(newX) + offsetX;
		y = screenToY(newY) + offsetY;
		screenX = xToScreen(x);
		screenY = yToScreen(y);
	};

	this.setID = function(newInfo){
		id = newInfo;
	};

	this.getID = function(){
		return id;
	};

	this.fall = function(){
		y -= 0.1;
	};

	Brick.moveLeft = function(){
		Brick.offset += 15;
		if(Brick.offset > leftBound){
			Brick.offset = leftBound;
		}
	};

	Brick.moveRight = function(){
		Brick.offset -= 15;
		if(Brick.offset < rightBound){
			Brick.offset = rightBound;
		}
	};

	//There should be some limit on how far up you can go
	Brick.moveUp = function(){
		Brick.verticalOffset -= 15;
	};

	Brick.moveDown = function(){
		Brick.verticalOffset += 15;
		if(Brick.verticalOffset > 0){
			Brick.verticalOffset = 0;
		}
	};

	this.isWithin = function(mouseX, mouseY){
		return (screenToX(mouseX) == x && screenToY(mouseY) == y)
	};

	Brick.makeSmaller = function(){
		if(Brick.BRICK_WIDTH > 2.5){
			Brick.BRICK_WIDTH *= 0.5;
			Brick.BRICK_HEIGHT *= 0.5;
			rightBound = p.width - (Brick.BRICK_WIDTH * COLUMNS + 10);
			//This always put the offset at the halfway point
			Brick.offset = (p.width - Brick.BRICK_WIDTH * COLUMNS)/2;
		}
	};

	Brick.makeLarger = function(){
		if(Brick.BRICK_WIDTH < <%= Global.tower.brick_width %>){
			Brick.BRICK_WIDTH *= 2;
			Brick.BRICK_HEIGHT *= 2;
			rightBound = p.width - (Brick.BRICK_WIDTH * COLUMNS + 10);
			Brick.offset = (p.width - Brick.BRICK_WIDTH * COLUMNS)/2;
		}
	};

	this.x = function(){
		return x;
	};

	this.y = function(){
		return y;
	};

	this.color = function(){
		return color;
	};

	//Do I use this function anywhere?
	this.level = function(){
		return Math.floor((y - 1) / BPL);
	};

	Brick.withinTower = function(x, offset){
		return screenToX(x) + offset >= 0 && screenToX(x) + offset < COLUMNS;
	};

	Brick.onLevel = function(y, offset){
		return Math.floor((screenToY(y) + offset - 1 ) / BPL) == Brick.level
	};

	//Given an coordinate, shows where on the screen to draw
	function xToScreen(thisX){
		return thisX * Brick.BRICK_WIDTH + Brick.offset;
	}

	function yToScreen(thisY){
		return p.height - (thisY+1 - Brick.level * BPL) * Brick.BRICK_HEIGHT + Brick.BRICK_HEIGHT/2;
	}

	// Converts the screen position to the nearest x,y position
	function screenToX(x){
		return Math.floor((x - Brick.offset)/Brick.BRICK_WIDTH);
	}

	function screenToY(y){
		return Math.floor((p.height-y+Brick.BRICK_HEIGHT/2-Brick.verticalOffset)/Brick.BRICK_HEIGHT) + Brick.level * BPL;
	}

	function pickFill(placed){
		if(placed){
			var a = 150;
		}else{
			var a = 255;
		}
		switch (color){
			case 0:
				//p.fill(170, 0, 0, a);
				p.fill(0, 0, 0, a);
				break;
			case 1:
				//p.fill(255, 140, 0, a);
				p.fill(255, 255, 255, a);
				break;
			case 2:
				p.fill(0, 0, 200, a);
				break;
			default:
				p.fill(0);
		}
	}

	function pickStrokeFill(){
		switch(color){
			case 0:
				p.stroke(255);
				break;
			case 1:
				p.stroke(0);
				break;
			default:
				p.stroke(100);
		}
	}

	this.draw = function(){
		draw(false);
	};

	this.draw = function(placed){
		if(x >= 0 && x < COLUMNS){
			pickFill(placed);
			p.stroke(100);
			p.strokeWeight(1);
			p.rect(xToScreen(x), yToScreen(y) - Brick.verticalOffset, Brick.BRICK_WIDTH, Brick.BRICK_HEIGHT);

			p.strokeWeight(2);
			pickStrokeFill(2);
			for(var i = 0; i < strength; i++){
				var xLerp = p.lerp(xToScreen(x), xToScreen(x) + Brick.BRICK_WIDTH, (i+1)/(strength+1));
				p.line(xLerp, yToScreen(y)+5- Brick.verticalOffset, xLerp, yToScreen(y) + Brick.BRICK_HEIGHT-5- Brick.verticalOffset);
			}
		}
	}
}