function Brick(startX, startY, p, color, strength){
	const BRICK_WIDTH = <%= Global.tower.brick_width %>;
	const BRICK_HEIGHT = <%= Global.tower.brick_height %>;
	//const COLUMNS = <%= Rails.configuration.x.bricks_layer %>;
	const COLUMNS = 100;
	const BPL = <%= Global.tower.level_height %>;
	const OVERLAP = <%= Global.tower.overlap %>
	//const OVERLAP = 2;

	Brick.towerWidth = BRICK_WIDTH * COLUMNS;
	if(Brick.offset == null){
		Brick.offset = (p.width - BRICK_WIDTH * COLUMNS)/2;
	}
	var leftBound = 10;
	var rightBound = p.width - (BRICK_WIDTH * COLUMNS) - 5;

	var x = startX;
	var y = startY;
	var screenX = xToScreen(x);
	var screenY = yToScreen(y);

	this.update = function(newX, newY, offsetX, offsetY){
		x = screenToX(newX) + offsetX;
		y = screenToY(newY) + offsetY;
		screenX = xToScreen(x);
		screenY = yToScreen(y);
	}

	//Does this brick appear on the level currently being shown?
	function onLevel(){
		if(y >= Brick.level * (BPL - OVERLAP) && y < Brick.level * (BPL - OVERLAP) + BPL){
			return true;
		}else{
			return false;
		}
	}

	this.fall = function(){
		y -= 0.1;
	}

	Brick.moveLeft = function(){
		if(Brick.offset < leftBound){
			Brick.offset += 10;
		}
	}

	Brick.moveRight = function(){
		if(Brick.offset > rightBound){
			Brick.offset -= 10;
		}
	}

	this.isWithin = function(mouseX, mouseY){
		if(screenToX(mouseX) == x && screenToY(mouseY) == y){
			return true;
		}else{
			return false;
		}
	}

	this.x = function(){
		return x;
	}

	this.y = function(){
		return y;
	}

	this.color = function(){
		return color;
	}

	//Do I use this function anywhere?
	this.level = function(){
		return (y - y % (BPL - OVERLAP)) / (BPL - OVERLAP);
	}

	Brick.withinTower = function(x, offset){
		return screenToX(x) + offset >= 0 && screenToX(x) + offset < COLUMNS;
	}

	//Given an coordinate, shows where on the screen to draw
	function xToScreen(thisX){
		return thisX * BRICK_WIDTH + Brick.offset;
	}

	function yToScreen(thisY){
		return p.height - (thisY+1 - Brick.level * (BPL - 2)) * BRICK_HEIGHT ;
	}

	// Converts the screen position to the nearest x,y position
	function screenToX(x){
		return Math.floor((x - Brick.offset)/BRICK_WIDTH);
	}

	function screenToY(y){
		return Math.floor((p.height-y)/BRICK_HEIGHT) + Brick.level * (BPL - 2);
	}

	function pickFill(placed){
		if(placed){
			var a = 150;
		}else{
			var a = 255;
		}
		switch (color){
			case 0:
				p.fill(200, 0, 0, a);
				break;
			case 1:
				p.fill(0, 200, 0, a);
				break;
			case 2:
				p.fill(0, 0, 200, a);
				break;
			default:
				p.fill(0);
		}
	}

	this.draw = function(){
		draw(false);
	}

	this.draw = function(placed){
		if(onLevel() && x >= 0 && x < COLUMNS){
			pickFill(placed);
			p.strokeWeight(strength*2+1);
			p.rect(xToScreen(x), yToScreen(y), BRICK_WIDTH, BRICK_HEIGHT);
		}
	}
}

// function BrickCluster(){
// 	const SHIPMENTSIZE = <%= Global.tower.shipment_size %>;

// 	var arrangment = generateArrangement();
// 	var bricks = [];

// 	//Generates the arrangement of bricks. Kind of hacky.
// 	function generateArrangement(){
// 		var ar = []
// 		for(var i = 0; i < SHIPMENTSIZE-1; i++){
// 			ar[i] = []
// 			for(var j = 0; j < 2; j++){
// 				ar[i][j] = Math.floor(Math.random()*3-1);
// 			}
// 		}
// 		//Don't put a new brick on top of my old brick!
// 		if(ar[0][0] == 0 && ar[0][1] == 0){
// 			ar[0][0] = 1;
// 		}
// 		if(ar[1][0] == 0 && ar[1][1] == 0){
// 			ar[1][0] = -1;
// 		}
// 		//If the first and second brick are in the same place
// 		//Throw away one of them
// 		if(ar[0][0] == ar[1][0] && ar[0][1] == ar[1][1]){
// 			ar.shift();
// 		}
// 		return ar;
// 	}

// 	this.draw = function(){

// 	}
// }