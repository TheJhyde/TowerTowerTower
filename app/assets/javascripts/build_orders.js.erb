$(document).on("page:change", function(){
	//Check if we're on the right page
	if($(".build_orders.new").length == 0){
		return
	}

	$(document).on('click', '.glyph', function(){
	  var $glyph = $(this)
	  $('#text_area').append($glyph.find("img").prop('outerHTML'));
	  $('#build_order_message').val(function(index, value){
	    return value + $glyph.find("p").attr("id") + " ";
	  });
	});

	//Ok, this is a little awkward looking but it lets me run 
	//p5 inside the above page check instead of just globally.
	var sketch = function(p){

		const BRICK_WIDTH = <%= Rails.configuration.x.brick_width %>;
		const BRICK_HEIGHT = <%= Rails.configuration.x.brick_height %>;
		const BRICKS = <%= Rails.configuration.x.shipment %>;
		const COLUMNS = <%= Rails.configuration.x.bricks_layer %>;
		const BPL = <%= Rails.configuration.x.level_height %>; //That's Bricks Per Level, of course
		var OFFSET;

		var finish = false;

		var tower = [];
		var bricks = [];
		var placedBricks = [];
		var level = 0;
		//This should be based on how high the tower is somehow
		//But that's a task for later
		var maxLevel = <%= Rails.configuration.x.max_levels %>;

		p.setup = function(){
			canvas = p.createCanvas(500, <%= Rails.configuration.x.screen_height %>);
			OFFSET = (p.width - BRICK_WIDTH * COLUMNS)/2;
			canvas.parent("canvas");
			loadTower(level);

			for(var i = 0; i < BRICKS; i++){
				bricks.push(Math.floor(Math.random() * 3));
			}
			updateBricks();
		};

		p.draw = function(){
			p.background(200);
			p.fill(100);
			//Draws the bricks from the tower
			for(var i = 0; i < tower.length; i++){
				pickFill(tower[i]["color"]);
				p.rect(xToScreen(tower[i]["x"]), yToScreen(tower[i]["y"]), BRICK_WIDTH, BRICK_HEIGHT);
			}
			//Draws the bricks which the player just placed
			for(var i = 0; i < placedBricks.length; i++){
				//Only place the brick if we're on the right level
				if(placedBricks[i][2] > level * BPL && placedBricks[i][2] < (level+1) * BPL){
					pickFill(placedBricks[i][0]);
					p.rect(xToScreen(placedBricks[i][1]), yToScreen(placedBricks[i][2]), BRICK_WIDTH, BRICK_HEIGHT);
				}

			}

			//Draws the brick you're about to place, if you haven't placed all the bricks yet
			if(finish == false && p.mouseX >= OFFSET && p.mouseX < p.width - OFFSET){
				pickFill(bricks[0]);
				p.rect(nearestBrickX(p.mouseX), nearestBrickY(p.mouseY), BRICK_WIDTH, BRICK_HEIGHT);
			}

			p.fill(0);
			if(level < maxLevel){
				p.triangle(25, 10, 5, 30, 45, 30);
			}
			if(level > 0){
				p.triangle(5, 35, 45, 35, 25, 55);
			}
		};

		p.mouseClicked = function(){
			if(p.mouseX > OFFSET && p.mouseX < OFFSET + BRICK_WIDTH * COLUMNS && p.mouseY > 0 && p.mouseY < p.height && !finish){
				//console.log("Placing a brick at " + screenToX(p.mouseX) + ", " + screenToY(p.mouseY));

				placedBricks.push([bricks[0], screenToX(p.mouseX), screenToY(p.mouseY)]);
				bricks.shift();
				if(bricks.length == 0){
					finish = true;
					$("#bricks").hide();
					$("#messages").hide();
					$.get('finished.js', function(){
						var colors = "";
						var x = "";
						var y = "";
						for(var i = 0; i < placedBricks.length; i++){
							colors += placedBricks[i][0] + " ";
							x += placedBricks[i][1] + " ";
							y += placedBricks[i][2] + " ";
						}
						$("#build_order_colors").val(colors);
						$("#build_order_x").val(x);
						$("#build_order_y").val(y);
					});
				}
				updateBricks();
			}else if(p.mouseX > 5 && p.mouseX < 45 && p.mouseY > 10 && p.mouseY < 30 && level < maxLevel){
				level++;
				loadTower(level);
			}else if(p.mouseX > 5 && p.mouseX < 45 && p.mouseY > 35 && p.mouseY < 55 && level > 0){
				level--;
				loadTower(level);
			}
		}

		function updateBricks(){
			var msg = "<b>BRICKS</b><br/>"
			for(var i = 0; i < bricks.length; i++){
				msg += "You have a " +colorWord(bricks[i])+ " brick.<br/>"
			}
			$("#bricks").html(msg);
		}

		function loadTower(requestedLevel){
			$.get('/tower.json', {level: requestedLevel}, function(data){
				tower = data;
				//console.log(tower.length);
			});
		}

		//----------------------------POSITIONAL FUNCTIONS--------------------------------
		// Converts a x coordinate from the database to a screen value
		function xToScreen(x){
			return x * BRICK_WIDTH + OFFSET;
		}

		function yToScreen(y){
			return p.height - (y+1 - level * BPL) * BRICK_HEIGHT ;
		}

		// Converts the screen position to the nearest x,y position
		function screenToX(x){
			return Math.floor((x-OFFSET)/BRICK_WIDTH);
		}

		function screenToY(y){
			return Math.floor((p.height-y)/BRICK_HEIGHT) + level * BPL;
		}

		//gives the screen coordinates of the nearest brick, based on a given screen coord
		function nearestBrickX(x){
			return xToScreen(screenToX(x));
		}

		function nearestBrickY(y){
			return yToScreen(screenToY(y));
		}


		//-------------------------------COLORS FUNCTION---------------------------------
		function pickFill(color){
			switch (color){
				case 0:
					p.fill(200, 0, 0);
					break;
				case 1:
					p.fill(0, 200, 0);
					break;
				case 2:
					p.fill(0, 0, 200);
					break;
				default:
					p.fill(0);
			}
		}

		function colorWord(color){
			switch (color){
				case 0:
					return "red";
					break;
				case 1:
					return "green";
					break;
				case 2:
					return "blue";
					break;
				default:
					return "ERROR";
			}
		}
	};

	var myp5 = new p5(sketch);
});