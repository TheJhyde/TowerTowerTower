$(document).on("page:change", function(){
	//If there's already a canvas loaded or it's the wrong page, don't load this page
	if($("canvas").size() > 0 || $(".build_orders.show").length == 0){
		return false;
	}

	var sketch = function(p){
		const maxLevel = <%= Rails.configuration.x.max_levels %>;

		var orders = [];
		var orderBricks = [];
		var tower = [];
		var orderIndex = 0;
		var collisions = [];
		var falling = [];

		var lastOrder;
		var orderPause = 1000;
		var state;
		var time;

		p.setup = function(){
			var url = window.location.href;
			time = parseInt(url.slice(url.lastIndexOf("/")+1));

			canvas = p.createCanvas(p.windowWidth - 550, <%= Rails.configuration.x.brick_height %> * <%= Rails.configuration.x.level_height %>);
			canvas.parent("canvas");

			Brick.level = 0;
			p.background(200);
			loadTower(Brick.level);

			// data = [
			// 	{"x": 1, "y": 1, "color": 1},
			// 	{"x": 1, "y": 0, "color": 2},
			// 	{"x": 2, "y": 0, "color": 1},
			// 	{"x": 3, "y": 0, "color": 0}
			// ];
		 // 	for(var i = 0; i < data.length; i++){
		 // 		tower.push(new Brick(data[i]["x"], data[i]["y"], p, data[i]["color"]));
		 // 	}

			$.get('/build_orders/' + time + '.json', function(data){
				orders = data;
				// orders = [
				// 	{colors: [1, 1, 1], x: [1, 2, 3], y: [1, 1, 1]}, //collide with tower
				// 	{colors: [1, 1, 1], x: [1, 2, 3], y: [2, 2, 1]}, //collide with other placed bricks
				// 	{colors: [1, 1, 1], x: [1, 2, 3], y: [5, 5, 5]}, //falls
				// 	{colors: [0, 0, 0], x: [5, 5, 5], y: [4, 5, 6]}, //falls, can't support itself
				// 	{colors: [2, 2, 2], x: [5, 6, 7], y: [0, 0, 0]}, //on the ground floor, shouldn't fall
				// 	{colors: [1, 1, 1], x: [5, 6, 7], y: [1, 2, 3]}
				// ];
				if(orders.length <= 0){
					state = 10;
				}else{
					state = 0;
				}
			});
			lastOrder = Date.now();
		};

		p.draw = function(){
			p.background(200);

			//Draws the bricks from the tower
			p.stroke(0);
			p.strokeWeight(1);
			for(var i = 0; i < tower.length; i++){
				tower[i].draw();
			}

			//Draws all the collisions
			for(var i = 0; i < collisions.length; i++){
				collisions[i].draw();
			}

			//Draws the bricks which have already been placed
			p.stroke(255);
			p.strokeWeight(2);
			for(var i = 0; i < orderBricks.length; i++){
				orderBricks[i].draw();
			}

			if(Date.now() - orderPause > lastOrder && state == 0){
				collisions = [];
				if(orderIndex >= orders.length){
					state++;
					fillFalling(Brick.level);
				}else{
					resolveOrder();
					lastOrder = Date.now();
				}
			}else if(state == 1){
				for(var i = falling.length - 1; i >= 0; i--){
					falling[i].fall();
					falling[i].draw();
					if(falling[i].y < 0){
						falling.slice(i, 1);
					}
				}
			}
		};

		//Loads the tower from the server
		function loadTower(requestedLevel){
			tower = [];
			$.get('/tower.json', {level: requestedLevel, time: time}, function(data){
			 	for(var i = 0; i < data.length; i++){
			 		tower.push(new Brick(data[i]["x"], data[i]["y"], p, data[i]["color"]));
			 	}
			});
		}

		//Takes the next order from the list and lists it
		function resolveOrder(){
			var nextOrder = orders[orderIndex];
			$("#messages ul li:nth-child(" + (orderIndex + 1) + ")").addClass("resolved");
			for(var i = 0; i < nextOrder["x"].length; i++){
				var towerIndex = hasBrick(nextOrder["x"][i], nextOrder["y"][i], tower);
				var placedIndex = hasBrick(nextOrder["x"][i], nextOrder["y"][i], orderBricks);
				if(towerIndex != -1){
					tower.splice(towerIndex, 1);
					collisions.push(new Brick(nextOrder["x"][i], nextOrder["y"][i], p, 5));
				}else if(placedIndex != -1){
					orderBricks.splice(placedIndex, 1);
					collisions.push(new Brick(nextOrder["x"][i], nextOrder["y"][i], p, 5));
				}else{
					orderBricks.push(new Brick(nextOrder["x"][i], nextOrder["y"][i], p, nextOrder["colors"][i]));
				}
			}
			if(orderBricks[orderBricks.length - 1].level() != Brick.level){
				//I would like a slight pause between moving up loading this brick. Hm....
				Brick.level = orderBricks[orderBricks.length - 1].level();
				loadTower(Brick.level);
			}
			orderIndex++;
		}

		//I'm pretty sure that like half of all entry level computer sciences courses
		//Have the sole purpose of avoiding writing programs like this.
		function hasBrick(x, y, array){
			for(var i = 0; i < array.length; i++){
				if(array[i].x() == x && array[i].y() == y){
					return i;
				}
			}
			return -1;
		}

		function fillFalling(level){
			//Sort in reverse order, with the lowest bricks at the back
			orderBricks.sort(function(a, b){return b.y() - a.y()});
			//Then go through it backwards
			for(var i = orderBricks.length - 1; i >= 0; i--){
				if(!hasSupport(orderBricks[i].x(), orderBricks[i].y()) && orderBricks[i].y() != 0 && orderBricks[i].level() == level){
					falling.push(orderBricks[i]);
					//Backwards because we'll be removing some bricks
					orderBricks.slice(i, 1);
				}
			}
		}

		function hasSupport(x, y){
			for(var i = -1; i < 2; i++){
				if(hasBrick(x+i, y - 1, tower) != -1 || hasBrick(x+i, y-1, orderBricks) != -1){
					//This shouldn't be necessary, since I'm removing the falling bricks in fallFalling
					//But for some reason it is necessary.
					//This whole section could honestly stand to be rewritten
					if(hasBrick(x+i, y-1, falling)== -1){
						return true;
					}
				}
			}
			return false;
		}
	}

	var myp5 = new p5(sketch);
});